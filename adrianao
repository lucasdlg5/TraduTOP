Primeiro
RESPOSTA 8
v = [2,-4,7,0,-1,4]; n = 6
int f(int v[], int n){

  if (n == 0)
  return 0;

  else {
    int s;
    s = f(v, n-1);
    if (v[n-1] > 0) s = s + v [n-1];
    return s;
  }
}

SEGUNDA
RESPOSTA = 8
int main()
{

int array [2][2][3] = {0,1,2,3,4,5,6,7,8,9,10,11};
printf("%d", array[1][0][2]);

return 0;
}

TERCEIRA
resposta = b. x = 11 y = 10
int x, y;

x = 10;

y = x++;

printf("x = %d \t", x );
printf("y = %d", y );

QUARTA
d. Somente um dos grupos de comandos pode ser executado de cada vez.

switch(<expressao>)

comando (s)
...
default:
  comando (s);


QUINTA

a. void push(pilha *p, int elemento) não necessita de parâmetros ou argumentos.
-- b. Ao final da execução do código, valor de p->topo será 0.
-- c. Ao final da execução do código, apenas o elemento 2 estará na pilha.
d. Não é possível determinar se existem erros no código.
e. void push(pilha *p, int elemento) não é uma função.

typedef struct{
  int elementos[100];
  int topo;
}pilha;

pilha * cria_pilha() {
  pilha * p = malloc(sizeof(pilha));
  p->topo = -1;
  return pilha;
}




void push( pilha *p, int elemento){
  if (p-> topo >= 99)
  return;
  p->elementos[++p->topo] = elemento;
}
int pop (pilha *p){
  int a = p->elementos[p->topo];
  p->topo--;
  return a;
}

int main(){
  pilha *p = cria_pilha();
  push(p,2);
  push(p,3);
  push(p,4);
  pop(p);
  push(p,2);
  int a= pop(p)+ pop(p);
  push(p, a);
  a += pop(p);
  printf("%d", a);
  return 0;
}

SEXTA
falso = pot 100
int numero(double a, int m){
  int r, pot;
  pot=1;
  while (m>1){
    pot = pot*10;
    m=m-1;
  }
  r=a*pot;
  return r;

}


void main()
{
printf("\n%d", numero(2.45334,3));
getch();

}

SETIMA
RESPOSTA a = if(a[j]==b[i]) {print (a[j]);}


for (i = 0 to 29){
  for (j = 0 to 39){

  }
}

OITAVA
VERDADEIRO

NONA
algoritmo ENEDE2008
RESPOSTA b. Apenas os itens II e III estão certos
variaveis
V[0..4] <- {2,0,4,3,1}:inteiro
I,J,A: inteiro
inicio
  para I <- 0 ate 3 passo 1 faca
    para J<-0 ate 3-I passo 1 faca
      se (V[J] > V[J+1]) entao
        A <- V[J]
        V[J] <- V[J+1]
        V[J+1] <- A
      fim se
      escreva V[0],V[1],V[2],V[3],V[4]
    fim para
  fim para
fim algoritmo


DEZ
CHUTE 47
Considere a função seguinte, codificada na linguagem de programação C (o operador % significa resto da divisão inteira):
Imagem da Questão
void surpresa (int n)
{
  int a = 0, b = 0;
   while (n>0)
   {
     if ((n % 2)==0)
     a = a + 1;
     else
     b =b +1;
     n = n/2;
   }

   printf("\n%d %d\n", a, b );
}



Os dois valores impressos pela função são iguais quando o valor de n é:

doze
d = 1
